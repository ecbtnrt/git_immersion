----------------------------------------------------------------------
h1. 配置

h3. 目的

* 配置git，准备工作

h2. 设置名字和信箱

p. 如果你之前从没有用过git，那你先需要做一些配置。运行下面的命令，把你
的名字和信箱告诉git。如果你的git已经配置好了，可以直接跳到这节的末尾。

执行：
git config --global user.name "你的名字"
git config --global user.email "your_email@whatever.com"

h2. 设置换行符参数

对于Unix/Mac用户：

execute:
git config --global core.autocrlf input
git config --global core.safecrlf true

对于Windows用户：

execute:
git config --global core.autocrlf true
git config --global core.safecrlf true

----------------------------------------------------------------------
h1. 更多的设置

h3. 目的

* 获取教程所需的的配置资料，准备执行教程。

h2. 获取教程资料包。

p. 从任意途径获取教程资料包：

* 教程提供的记忆棒里
* 访问网址 "http://onestepback.org/download/git_tutorial.zip":http://onestepback.org/download/git_tutorial.zip

h2. 解压教程

p. 资料包里应该含有主目录”git_tutorial“和三个子目录：

* html -- html文件。用你的浏览器打开html/index.html
* work -- 空的工作目录，在这里创建你的库。
* repos -- 已经准备好的Git库，这样你可以跳到教程的任意节。如果你把你的库搞乱了，只要把对应节的实验目录考到你的工作目录就行。

----------------------------------------------------------------------
h1. 创建一个项目

h3. 目的

* 学习如何从头创建一个git库。

h2. 创建一个“Hello, World”程序

p. 从一个空目录开始，创建一个名叫“hello”的目录，然后创建名叫 @hello.rb@ 的文件，内
容如下。

Execute:
mkdir hello
cd hello

File: hello.rb
puts "Hello, World"
EOF

h2. 创建库

p. 你现在有了一个只含有一个文件的目录。为了将这个目录变为git库，执行git init命令。

Execute:
git init
=init
+git config user.name "Jim Weirich"
+git config user.email "jim (at) edgecase.com"

Output:
=init
EOF

h2. 将程序添加到库

现在把“Hello, World”程序加入到库里。

Execute:
git add hello.rb
=add
git commit -m "First Commit"
=commit

p. 你应该看到……

Output:
=add
=commit
EOF

----------------------------------------------------------------------
h1. 检查状态

h3. 目的

* 学习如何检查库的状态

h2. 检查库的状态

p. 用命令 @git status@ 来检查库的当前状态。

Execute:
git status
=status

p. 你应该看到

Output:
=status
EOF

p. 这个命令报告库里没有需要提交的修改。也就是说工作目录的当前状态和库里的状态是一样的。
没有尚未提交的修改。

p. 我们将持续使用 @git status@ 命令来监控工作目录和库之间的状态。

----------------------------------------------------------------------
h1. 做些改动

h3. 目的

* 学习如何监控工作目录的状态

h2. 改变“Hello, World”程序。

p. 现在是修改hello程序的时候了，让它从命令行接受一个参数。把文件改为：

File: hello.rb
puts "Hello, #{ARGV.first}!"
EOF

h2. 检查状态

p. 现在检查工作目录的状态。

Execute:
!git status
=status

p. 你应该看到……

Output:
=status
EOF

p. 首先注意到，git发现 @hello.rb@ 文件被改动了，但是git还没有接受这些改动。

p. 然后注意到，状态消息也提示了一些你之后要做的事情。如果你想把这些改动加入到库里，就执行
@git add@ 命令。另一方面 @git checkout@ 命令可以放弃这些改动。

h2. 下一页

p. 来让我们跟踪改动吧。

----------------------------------------------------------------------
h1. 跟踪改动

h3. 目的

* 学习如何跟踪改动，以便之后的提交

h2. 加入改动

p. 现在告诉git来跟踪改动。然后检查状态

Execute:
git add hello.rb
=add
git status
=status

p. 你应该看到……

Output:
=add
=status
EOF

p. 文件 @hello.rb@ 的改动已经被跟踪。这意味着git现在知道这些改动，但是这些改动还没有 _持久_
记录到库里。之后的提交操作将记录已经跟踪的改动。

p. 如果你决定 _不打算_ 提交这些改动，status命令会提示你用 @git reset@ 命令来取消对这些改动
的跟踪。

----------------------------------------------------------------------
h1. 跟踪并提交

p. git里分离出跟踪这个步骤的原因，源于以下原则：除非你需要对源码做控制，否则不和版本控制打交道。
你可以一直在工作目录上做改动，然后在某个时刻你想对源码做控制，git就让你通过诸多准确记录了你的改
动的小规模提交，来记录你所有的变动。

p. 举个例子，假设你改了三个文件（ @a.rb@ ， @b.rb@ ，和 @c.rb@ ）。现在你想提交所有的改动，
但是你想将 @a.rb@ 和 @b.rb@ 的改动一起提交，而 @c.rb@ 里的改动和前两个文件的改动没有逻辑关系，
因此需要分别提交。

p. 你可以照着下面的做法：

pre(instructions).
git add a.rb
git add b.rb
git commit -m "Changes for a and b"

pre(instructions).
git add c.rb
git commit -m "Unrelated change to c"

p. 将跟踪和提交分离，你就可以更加精细的调整每次提交的内容。

----------------------------------------------------------------------
h1. 提交修改

h3. 目的

* 学习如何将修改提交到库里

h2. 提交修改

p. 好了，关于跟踪已经讲的够多了。让我们把正在跟踪的修改提交到库里吧。

p. 当你之前使用 @git commit@ 命令讲初始版本的 @hello.rb@ 文件提交入库时，你
在命令行上使用了 @-m@ 标志来加入一段对提交的注释。commit命令还允许以交互的形式
对提交进行注释。让我们现在来试试。

p. 如果你在命令行上忽略 @-m@ 标识，git将会弹出你选择的编辑器。编辑器将在下面的
列表中选择（按照顺序）：

* GIT_EDITOR环境变量
* 设置文件中的core.editor配置
* VISUAL环境变量
* EDITOR环境变量

p. 我把我的EDITOR环境变量设为了 @emacsclient@ 。

p. 所以现在提交并且检查状态。

Execute:
-git commit
+git commit -m "Using ARGV"

p. 你应该在你的编辑器看到下面的内容：

Output:
|
# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
# On branch master
# Changes to be committed:
#   (use "git reset HEAD <file>..." to unstage)
#
#	modified:   hello.rb
#
EOF

p. 在第一行，输入注释：“Using ARGV”。保存文件并退出。你应该看到……

Output:
git commit
Waiting for Emacs...
[master 569aa96] Using ARGV
 1 files changed, 1 insertions(+), 1 deletions(-)
EOF

p. “Waiting for Emacs...”这行输出来自 @emacsclient@ 程序，这个程序将文件发到
正在运行的 emacs 程序并且等待文件关闭。其他的输出是git标准的提交信息。

h2. 检查状态

p. 最后，让我们再次检查状态。

Execute:
!git status
=status

你应该看到……

Output:
=status
EOF

p. 工作目录已经没有未记录的修改，现在可以继续后面的工作了。

----------------------------------------------------------------------
h1. 改变，而不仅仅是文件

h3. 目的

* 学习git是根据改变在工作，而不是文件。

p. 大部分源码控制系统都是根据文件在工作。如果你把一个文件加入到源码控制后，系统将跟
踪这个时刻后文件的所有改动。

p. 比起文件本身，git更关注改动而不是文件。当你执行 @git add file@ ，你并不是让
git把文件加入到库里，而是让git记录当前状态的文件，以便之后的提交。

p. 我们在这节里来试试这个不同之处。

h2. 第一次修改：支持默认名字

p. 修改“Hello, World”程序，如果命令行没有带参数，就使用一个默认值。

File: hello.rb
name = ARGV.first || "World"

puts "Hello, #{name}!"
EOF

h2. 加入这些修改

p. 现在将这些修改加入到跟踪区域。

Execute:
git add hello.rb

h2. 第二个修改：加入注释

p. 现在将一段注释加入“Hello, World”程序。

File: hello.rb
# Default is "World"
name = ARGV.first || "World"

puts "Hello, #{name}!"
EOF

h2. 检查当前状态

Execute:
!git status
=status

p. 你应该看到……

Output:
=status
EOF

p. 注意 @hello.rb@ 是怎样在状态里被列出两次的。第一次改动（加入默认值）已经被跟踪
等待提交。第二次改动（加入注释）则没有被跟踪。如果你现在提交，注释将不会保存到库里。

p. 让我们试试。

h2. 提交

p. 提交被跟踪的修改（增加默认值），然后再检查状态。

Execute:
git commit -m "Added a default value"
=commit
git status
=status2

p. 你应该看到……

Output:
=commit
=status2
EOF

p. status命令告诉你 @hello.rb@ 文件还有未记录的修改，但这个修改不在跟踪环境里。

h2. 加入第二次修改

p. 现在将第二次修改加入跟踪区域，之后执行git status。

Execute:
git add .
!git status
=status3

p(note). *注意:* 我们使用当前路径（‘.’）做为加入的文件。这个确实只是一个加入当前目录及
子目录里所有改动的文件的捷径。不过因为这个会把所有东西都加进来，所以 _最好_ 在执行<tt>add .</tt>
前检查一下状态，确认都是想跟踪的文件后再执行。

p(note). 我想让你知道“add .”只是个技巧。不过教程后面为了保险，都会明确指定增加的文件。

p. 你将看到……

Output:
=status3
EOF

p. 现在已经跟踪了第二个改动，准备提交。

h2. 提交第二个改动

Execute:
git commit -m "Added a comment"

----------------------------------------------------------------------
h1. 历史

h3. 目的

* 学习如何查看项目的历史。

p. 命令 @git log@ 用来取得项目之前所有修改的列表。

Execute:
git log
=log

p. 你应该看到……

Output:
=log
EOF

p. 这里列出了我们之前对库做的四次修改。

h2. 单行历史

p. 你可以用很多参数精确控制 @log@ 命令的显示方式。我喜欢单行格式：

Execute:
git log --pretty=oneline
=oneline

p. 你应该看到……

Output:
=oneline
EOF

h2. 控制显示哪些项

p. 有很多的选项可以指定哪些信息项显示在log里。让我们来试试下面这些选项：

pre(instructions).
git log --pretty=oneline --max-count=2
git log --pretty=oneline --since='5 minutes ago'
git log --pretty=oneline --until='5 minutes ago'
git log --pretty=oneline --author=<your name>
git log --pretty=oneline --all

p. 查看man git-log来获得所有细节。

h2. 来点花活儿

p. 下面是我用来检查上周都提交了哪些修改的命令。如果我想查某个人的提交，加入 @--author=jim@
就行了。

pre(instructions).
git log --all --pretty=format:"%h %cd %s (%an)" --since='7 days ago'

h2. 白金版log格式

p. 假以时日，我觉得我大部份工作中更喜欢下面的log格式。

Execute:
git log --pretty=format:"%h %ad | %s%d [%an]" --graph --date=short
=ultimate

看起来像这样：

Output:
=ultimate
EOF

p. 让我们来看看细节：

* @--pretty="..."@ 定义了输出格式。
* @%h@ 代表提交的精简hash码
* @%d@ 这个提交的一些修饰信息（比如，分支顶或者tag）
* @%ad@ 作者提交的日期
* @%s@ 提交时的注释
* @%an@ 提交人的名字
* @--graph@ 让git用字符图的方式显示提交树
* @--date=short@ 显示简短的日期格式

p. 不过，要是用这种方式看log，每次要输入的命令太长了。好在我们将在下节学习
如何使用别名来缩短git命令。

h2. 其他工具

p. 在浏览log历史时，<code>gitx</code> （在Mac电脑上）和 <code>gitk</code> （任何平台）
都很好用。

----------------------------------------------------------------------
h1. 别名

h3. 目的

* 学习如何给git命令起别名

h2. 一般的别名

p. +git status+ ， +git add+ ， +git commit+ ，和 +git checkout+ 这些命令太
常用了，缩写一下会很有帮助。

p. 把下面的内容加到你$HOME目录下的.gitconfig文件。

file: .gitconfig
[alias]
  co = checkout
  ci = commit
  st = status
  br = branch
  hist = log --pretty=format:\"%h %ad | %s%d [%an]\" --graph --date=short
  type = cat-file -t
  dump = cat-file -p
EOF

p. 这些配置已经覆盖了签出，提交和状态显示命令。而之前的一个配置覆盖了 @log@ 命令。
现在，你可以在任何时候用 @git co@ 来代替 @git checkout@ ，同样的，@git st@ 代
替 @git status@， @git ci@ 代替 @git commit@ 。最棒的是， @git hist@ 可以
代替之前 @log@ 那一长串的命令。

p. 接下来试着添加个新命令。

h2. 在 @.gitconfig@ 里定义的别名 @hist@ 

p. 这个教程里大部分时候我会继续使用完整的命令。唯一的例外是 @hist@， 我会用这个别名
来代替所有需要查看git log的情况。如果你想继续的话，确认你的 @.gitconfig@ 文件里有
@hist@ 别名的定义。

h2. @Type@ 和 @Dump@

p. 我们来加几条还没有涉及到的命令的别名。命令 @git branch@ 很快就会用到。而 @git cat-file@
在浏览git库时很有用，一会儿也会用到。

h2. Shell里的别名（可选）

p(note). *注意：* 这节是为了那些使用posix风格的shell的人写的。Windows用户和其他
非posix风格shell的用户可以忽略这些内容跳到下一节。

p. 如果你的shell支持别名活着快捷方式，那你也可以通过shell来加别名。下面是我自己用的一些别名：

file: .profile
alias gs='git status '
alias ga='git add '
alias gb='git branch '
alias gc='git commit'
alias gd='git diff'
alias go='git checkout '
alias gk='gitk --all&'
alias gx='gitx --all'

alias got='git '
alias get='git '
EOF

p. 缩写 @go@ 非常完美的代表了 @git checkout@ 。我可以这样做：

pre(instructions). go <branch>

p. 来切换到一个特殊的分支。

p. 而且，我经常把 @git@ 误拼成 @get@ or @got@ ，所以我干脆把后两个定义为 @git@ 的别名。

----------------------------------------------------------------------
h1. 取得旧版本

h3. 目的

* 学习如何将之前的快照签入到工作目录。

p. 其实很容易就可以回到过去。命令checkout可以把库里任意时刻的快照拷贝到工作目录。

h2. 取得之前版本的hash值

Execute:
git hist
=log

p(note). *注意：* 你已经在 @.gitconfig@ 文件里定义了 @hist@，对吧？如果没有的
话，复习“别名”那节。

Output:
=log
EOF

p. 检查log的输出，找到第一次提交的hash值。它应该是 @git hist@ 输出的最后一行。把
这个值（前7个字符就足够了）用在下面的命令里。然后检查hello.rb文件的内容。

Set: hash=hash_for("First Commit")
Execute:
git checkout <hash>
=checkout
cat hello.rb
=cat

p(note). *注意：* 这里给出的命令是Unix风格的命令，适合Mac和Linux系统。不过，Windows
用户需要转换成自己使用的命令。

p(note). *注意：* 很多命令都依赖库里的hash值。由于你库里的hash值和教程里有很大不
同，所有命令里类似&lt;hash&gt;或者&lt;treehash&gt;的地方，都需要你替换成你库里
对应的hash值。

p. 你应该看到……

Output:
=checkout
=cat
EOF

p. @checkout@ 命令的输出完美展示了当前的状态。如果使用老版本的git，可能会抱怨没有一个本地分
支。不过，现在不需要担心这个。

p. 注意hello.rb文件的内容已经是老黄历了。

h2. 返回主分支的最新版本

Execute:
git checkout master
=checkout2
cat hello.rb
=cat2

p. 你应该看到……

Output:
=checkout2
=cat2
EOF

p. ‘master’是默认分支的名字。用名字签出一个分支，将会得到这个分支的最新版本。

----------------------------------------------------------------------
h1. 给版本打标签

h3. 目的

* 学习如何提交一个命名标签，以便今后可以用标签来引用某个版本

p. 让我们把hello程序的当前版本起名叫版本1（v1）。

h2. 给版本1打标签

Execute:
git tag v1
=tag

p. 现在你可以通过v1这个标签来引用当前版本了。

h2. 给以前的版本打标签

p. 让我们给当前版本之前的一个版本打上v1-beta的标签。首先我们需要签出上一个版本。除了
去查找hash值，我们这回使用 @^@ 符号来表示“v1的父版本”。

p(note). 如果 @v1@^ 符号有问题，你可以试试 @v1~1@ ，这个和前面的符号指代同样的版本。
这个符号表示“v1之前的第一个历史记录”。

Execute:
git checkout v1^
=checkout
cat hello.rb
=cat

Output:
=checkout
=cat
EOF

p. 看，这个含有默认值的版本就是我们加入注释 _之前_ 的版本。现在给这个打上v1-beta
的标签。

Execute:
git tag v1-beta

h2. 通过标签名来签出

p. 现在让我们在两个打了标签的版本间来回切换。

Execute:
git checkout v1
=cov1
git checkout v1-beta
=cov1beta

Output:
=cov1
=cov1beta
EOF

h2. 使用 @tag@ 命令查看标签

p. 你可以用命令 @git tag@ 查看有哪些可用标签。

Execute:
git tag
=tag2

Output:
=tag2
EOF

h2. 在日志里浏览标签

p. 你也可以在日志里查看标签。

Execute:
git hist master --all
=hist

Output:
=hist
EOF

p. 你可以看到两个标签（ @v1@ 和 @v1-beta@ ），还有分支名（ @master@ ），都列在
日志的输出里。而且 @HEAD@ 显示了当前签出的提交（此刻就是 @v1-beta@ ）。

----------------------------------------------------------------------
h1. （在跟踪前）撤销本地的修改

h3. 目的

* 学习如何还原工作目录中的修改

h2. 签出主分支

p. 在继续工作前，确认你签出了主分支的最新修改。

Execute:
git checkout master

h2. 修改hello.rb

p. 有时，你在本地工作目录修改了文件，但是又希望能回到提交时的内容。checkout命令
可以做到这点。

修改hello.rb，加入一条错误注释。

File: hello.rb
# This is a bad comment.  We want to revert it.
name = ARGV.first || "World"

puts "Hello, #{name}!"
EOF

h2. 检查状态

p. 首先，检查工作目录的状态。

Execute:
!git status
=status

Output:
=status
EOF

p. 我们看到 @hello.rb@ 文件已经修改了，但还没被跟踪。

h2. 在工作目录中取消修改

p. 使用 @checkout@ 命令来签出库中版本的 @hello.rb@ 文件。

Execute:
git checkout hello.rb
=checkout
!git status
=status2
cat hello.rb
=cat

Output:
=checkout
=status2
=cat
EOF

p. status命令告诉我们现在工作目录没有未记录的修改。而且“错误注释”也不在文件里了。

----------------------------------------------------------------------
h1. （在提交之前）恢复已跟踪的修改

h3. 目的

* 学习如何恢复已经被跟踪的修改

h2. 修改文件并跟踪

p. 修改文件 @hello.rb@ ，加入一条错误注释

File: hello.rb
# This is an unwanted but staged comment
name = ARGV.first || "World"

puts "Hello, #{name}!"
EOF

p. 然后跟踪这次修改。

Execute:
git add hello.rb

h2. 检查状态

p. 检查状态，看看这个你不想要的修改。

Execute:
git status
=status

Output:
=status
EOF

p. 状态显示这个修改已经被跟踪并等待提交。

h2. 重置跟踪区

p. 多好，status的输出明确告诉我们该如何不再跟踪一个修改。

Execute:
git reset HEAD hello.rb
=reset

Output:
=reset
EOF

p. @reset@ 命令将把跟踪区重置到和HEAD版本一致的状态。这就把跟踪区里已经跟踪的修改
清空了。

p. @reset@ 命令（默认）不修改当前工作目录。所以工作目录里依旧会保留不想要的注释。
我们可以用上一节介绍的 @checkout@ 命令来移出工作目录里不想要的修改。

h2. 签出之前提交的版本

Execute:
git checkout hello.rb
git status
=status2

Output:
=status2
EOF

p. 现在我们的工作目录又变得整洁了。

----------------------------------------------------------------------
h1. 撤销已提交的修改

h3. 目的

* 学习如何撤销已经提到本地库离的修改。

h2. 撤销提交

p. 有时你会突然意识到你刚刚提交的修改有问题，希望撤销这次提交。有好几种方法可以做到，
我们这节里学习最安全的一种方法。

p. 其实，我们撤销修改，就是再提交一次撤销了之前修改的新修改。

h2. 修改文件并提交。

p. 像下面那样修改 @hello.rb@ 文件。

File: hello.rb
# This is an unwanted but committed change
name = ARGV.first || "World"

puts "Hello, #{name}!"
EOF

Execute:
git add hello.rb
git commit -m "Oops, we didn't want this commit"

h2. 创建撤销的提交

p. 为了撤销一个一提交的修改，我们需要提交一个修改，这个修改移除了刚提交的不想要的内容。

Execute:
-git revert HEAD
+git revert HEAD --no-edit
=revert

p. 这个将打开编辑器。你可以编辑默认的提交信息，或者使用默认的。保存并关闭文件。你将看到……

Output:
=revert
EOF

p. 因为我们要恢复的是最后一次提交，我们可以用 @HEAD@ 作为要恢复的版本参数。只需要
简单的指定对应的hash值，我们就可以恢复历史上的任意一个提交，

p(note). *注意：* 输出中的 @--no-edit@ 可以被忽略。只有在不想打开编辑器的情况下
才会用到这个参数。

h2. 检查日志

p. 检查日志，将会看到不想要的提交和恢复的提交都在我们的库里。

Execute:
git hist
=hist

Output:
=hist
EOF

p. 这个技术可以恢复任意提交（虽然有时需要你手动解决冲突）。即便对于在远程库上公开分享
的分支，也可以安全使用。

h2. 接下来

p. 接下来，让我们看看如何恢复库历史里最近的提交。

----------------------------------------------------------------------
h1. Removing Commits from a Branch

h3. Goals

* Learn how to remove the most recent commits from a branch

p. The @revert@ command of the previous section is a powerful command
that lets us undo the effects of any commit in the repository.
However, both the original commit and the "undoing" commit are visible
in the branch history (using the @git log@ command).

p. Often we make a commit and immediately realize that it was a
mistake.  It would be nice to have a "take back" command that would
allow us to pretend that the incorrect commit never happened.  The
"take back" command would even prevent the bad commit from showing up
the @git log@ history.  It would be as if the bad commit never
happened.

h2. The @reset@ command

p. We've already seen the @reset@ command and have used it to set the
staging area to be consistent with a given commit (we used the HEAD
commit in our previous lab).

p. When given a commit reference (i.e. a hash, branch or tag name),
the @reset@ command will ...

# Rewrite the current branch to point to the specified commit
# Optionally reset the staging area to match the specified commit
# Optionally reset the working directory to match the specified commit

h2. Check Our History

p. Let's do a quick check of our commit history.

Execute:
git hist
=hist

Output:
=hist
EOF

p. We see that we have an "Oops" commit and a "Revert Oops" commit as
the last two commits made in this branch.  Let's remove them using
reset.

h2. First, Mark this Branch

p. But before we remove the commits, let's mark the latest commit with
a tag so we can find it again.

Execute:
git tag oops

h2. Reset to Before Oops

p. Looking at the log history (above), we see that the commit tagged
'v1' is the commit right before the bad commit.  Let's reset the
branch to that point.  Since that branch is tagged, we can use the tag
name in the reset command (if it wasn't tagged, we could just use the
hash value).

Execute:
git reset --hard v1
=reset
git hist
=hist2

Output:
=reset
=hist2
EOF

p. Our master branch now points to the v1 commit and the Oops commit
and the Revert Oops commit are no longer in the branch.  The @--hard@
parameter indicates that the working directory should be updated to be
consistent with the new branch head.

h2. Nothing is Ever Lost

p. But what happened to the bad commits?  It turns out that the
commits are still in the repository.  In fact, we can still reference
them.  Remember that at the beginning of this lab we tagged the
reverting commit with the tag "oops".  Let's look at _all_ the commits.

Execute:
git hist --all
=hist3

Output:
=hist3
EOF

p. Here we see that the bad commits haven't disappeared.  They are
still in the repository.  It's just that they are no longer listed in
the master branch.  If we hadn't tagged them, they would still be in
the repository, but there would be no way to reference them other than
using their hash names.  Commits that are unreferenced remain in the
repository until the system runs the garbage collection software.

h2. Dangers of Reset

p. Resets on local branches are generally safe.  Any "accidents" can
usually be recovered from by just resetting again with the desired
commit.

p. However, if the branch is shared on remote repositories, resetting
can confuse other users sharing the branch.

----------------------------------------------------------------------
h1. Remove the oops tag

h3. Goals

* Remove the oops tag (housekeeping)

h2. Removing tag oops

p. The oops tag has served its purpose.  Let's remove it and allow the
commits it referenced to be garbage collected.

Execute:
git tag -d oops
=tag
git hist --all
=hist

Output:
=tag
=hist
EOF

p. The oops tag is no longer listed in the repository.

----------------------------------------------------------------------
h1. Amending Commits

h3. Goals

* Learn how to amend an existing commit

h2. Change the program then commit

p. Add an author comment to the program.

File: hello.rb
# Default is World
# Author: Jim Weirich
name = ARGV.first || "World"

puts "Hello, #{name}!"
EOF

Execute:
git add hello.rb
git commit -m "Add an author comment"

h2. Oops, Should have an Email

p. After you make the commit, you realize that any good author comment
should have an email included.  Update the hello program to include an
email.

File: hello.rb
# Default is World
# Author: Jim Weirich (jim@somewhere.com)
name = ARGV.first || "World"

puts "Hello, #{name}!"
EOF

h2. Amend the Previous Commit

p. We really don't want a separate commit for just the email.  Let's
amend the previous commit to include the email change.

Execute:
git add hello.rb
=add
git commit --amend -m "Add an author/email comment"
=commit

Output:
=add
=commit
EOF


h2. Review the History

Execute:
git hist
=hist

Output:
=hist
EOF

p. We can see the original "author" commit is now gone, and it is
replaced by the "author/email" commit.  You can achieve the same
effect by resetting the branch back one commit and then recommitting
the new changes.

----------------------------------------------------------------------
h1. Moving Files

h3. Goals

* Learn how to move a file within a repository.

h2. Move the hello.rb file into a lib directory.

p. We are now going to build up the structure of our little
repository.  Let's move the program into a lib directory.

Execute:
mkdir lib
=mkdir
git mv hello.rb lib
=move
!git status
=status

Output:
=mkdir
=move
=status
EOF

p. By using git to do the move, we inform git of 2 things

# That the file @hello.rb@ has been deleted.
# The file @lib/hello.rb@ has been created.

p. Both of these bits of information are immediately staged and ready
to be committed.  The git status command reports that the file has been
moved.

h2. Another way of moving files

p. One of the nice things about git is that you can forget about
source control until the point you are ready to start committing code.
What would happen if we used the operating system command to move the
file instead of the git command?

p. It turns out the following set of commands is identical to what we
just did.  It's a bit more work, but the result is the same.

p(command). We could have done:

pre(instructions). mkdir lib
mv hello.rb lib
git add lib/hello.rb
git rm hello.rb

h2. Commit the new directory

p. Let's commit this move.

Execute:
git commit -m "Moved hello.rb to lib"

----------------------------------------------------------------------
h1. More Structure

h3. Goals

* Add another file to our repository

h2. Now add a Rakefile

p. Let's add a rakefile to our repository.  The following one will do
nicely.

File: Rakefile
#!/usr/bin/ruby -wKU

task :default => :run

task :run do
  require './lib/hello'
end
EOF

p. Add and commit the change.

Execute:
git add Rakefile
git commit -m "Added a Rakefile."

p. You should be able to use Rake to run your hello program now.

Execute:
rake
=rake

Output:
=rake
EOF

----------------------------------------------------------------------
h1. Git Internals: The .git directory

h3. Goals

* Learn about the structure of the @.git@ directory

h2. The @.git@ Directory

p. Time to do some exploring.  First, from the root of your project
directory...

Execute:
ls -C .git
=lsgit

Output:
=lsgit
EOF

p. This is the magic directory where all the git "stuff" is stored.
Let's peek in the objects directory.

h2. The Object Store

Execute:
ls -C .git/objects
=lsobjs

Output:
=lsobjs
EOF

p. You should see a bunch of directories with 2 letter names.  The
directory names are the first two letters of the sha1 hash of the
object stored in git.

h2. Deeper into the Object Store

Set: dir=`ls .git/objects | head -1`.strip
Execute:
ls -C .git/objects/<dir>
=lsobjs2

Output:
=lsobjs2
EOF

p. Look in one of the two-letter directories.  You should see some
files with 38-character names.  These are the files that contain the
objects stored in git.  These files are compressed and encoded, so
looking at their contents directly won't be very helpful, but we will
take a closer look in a bit.

h2. Config File

Execute:
cat .git/config
=cat

Output:
=cat
EOF

p. This is a project-specific configuration file.  Config entries in
here will override the config entries in the @.gitconfig@ file in your
home directory, at least for this project.

h2. Branches and Tags

Execute:
ls .git/refs
=refs
ls .git/refs/heads
=refhead
ls .git/refs/tags
=reftags
cat .git/refs/tags/v1
=refv1

Output:
=refs
=refhead
=reftags
=refv1
EOF

p. You should recognize the files in the tags subdirectory.  Each file
corresponds to a tag you created with the @git tag@ command earlier.
Its content is just the hash of the commit tied to the tag.

p. The heads directory is similar, but is used for branches rather
than tags.  We only have one branch at the moment, so all you will see
is master in this directory.

h2. The HEAD File

Execute:
cat .git/HEAD
=head

Output:
=head
EOF

p. The HEAD file contains a reference to the current branch.  It
should be a reference to master at this point.

----------------------------------------------------------------------
h1. Git Internals: Working directly with Git Objects

h3. Goals

* Explore the structure of the object store
* Learn how to use the SHA1 hashes to find content in the repository

p. Now let's use some tools to probe git objects directly.

h2. Finding the Latest Commit

Execute:
git hist --max-count=1
=log

p. This should show the latest commit made in the repository.  The
SHA1 hash on your system is probably different that what is on mine,
but you should see something like this.

Output:
=log
EOF

h2. Dumping the Latest Commit

Using the SHA1 hash from the commit listed above ...

Set: hash=hash_for("Added a Rakefile")
Execute:
git cat-file -t <hash>
=type
git cat-file -p <hash>
=dump

Here's my output ...

Output:
=type
=dump
EOF

p(note). *NOTE:* If you defined the 'type' and 'dump' aliases from
the aliases lab, then you can type @git type@ and @git dump@ rather
than the longer cat-file commands (which I never remember).

p. This is the dump of the commit object that is at the head of the
master branch.  It looks a lot like the commit object from the
presentation earlier.

h2. Finding the Tree

p. We can dump the directory tree referenced in the commit.  This
should be a description of the (top level) files in our project (for
that commit).  Use the SHA1 hash from the "tree" line listed above.

Set: treehash=hash_in(var['hash'], 'tree')
Execute:
git cat-file -p <treehash>
=treedump

p. Here's what my tree looks like...

Output:
=treedump
EOF

p. Yep, I see the Rakefile and the lib directory.

h2. Dumping the lib directory

Set: libhash=hash_in(var['treehash'], 'lib')
Execute:
git cat-file -p <libhash>
=libdump

Output:
=libdump
EOF

p. There's the @hello.rb@ file.

h2. Dumping the @hello.rb@ file

Set: rbhash=hash_in(var['libhash'], 'hello')
Execute:
git cat-file -p <rbhash>
=rbdump

Output:
=rbdump
EOF

p. There you have it.  We've dumped commit objects, tree objects and
blob objects directly from the git repository.  That's all there is to
it, blobs, trees and commits.

h2. Explore On You Own

p. Explore the git repo manually on your own.  See if you can find the
original hello.rb file from the very first commit by manually
following the SHA1 hash references starting in the latest commit.

----------------------------------------------------------------------
h1. Creating a Branch

h3. Goals

* Learn how to create a local branch in a repository

p. It's time to do a major rewrite of the hello world functionality.
Since this might take awhile, you'll want to put these changes into a
separate branch to isolate them from changes in master.

h2. Create a Branch

p. Let's call our new branch 'greet'.

Execute:
git checkout -b greet
!git status

p(note). *NOTE:* @git checkout -b <branchname>@ is a shortcut for @git
branch <branchname>@ followed by a @git checkout <branchname>@.

p. Notice that the git status command reports that you are on the
'greet' branch.

h2. Changes for Greet: Add a Greeter class.

File: lib/greeter.rb
class Greeter
  def initialize(who)
    @who = who
  end
  def greet
    "Hello, #{@who}"
  end
end
EOF

Execute:
git add lib/greeter.rb
git commit -m "Added greeter class"

h2. Changes for Greet: Modify the main program

p. Update the hello.rb file to use greeter

File: lib/hello.rb
require 'greeter'

# Default is World
name = ARGV.first || "World"

greeter = Greeter.new(name)
puts greeter.greet
EOF

Execute:
git add lib/hello.rb
git commit -m "Hello uses Greeter"

h2. Changes for Greet: Update the Rakefile

p. Update the Rakefile to use an external ruby process

File: Rakefile
#!/usr/bin/ruby -wKU

task :default => :run

task :run do
  ruby '-Ilib', 'lib/hello.rb'
end
EOF

Execute:
git add Rakefile
git commit -m "Updated Rakefile"

h2. Up Next

p. We now have a new branch called *greet* with 3 new commits on it.
Next we will learn how to navigate and switch between branches.

----------------------------------------------------------------------
h1. Navigating Branches

h3. Goals

* Learn how to navigate between the branches of a repository

p. You now have two branches in your project:

Execute:
git hist --all
=log

Output:
=log
EOF

h2. Switch to the Master Branch

p. Just use the @git checkout@ command to switch between branches.

Execute:
git checkout master
=checkout
cat lib/hello.rb
=cat

Output:
=checkout
=cat
EOF

p. You are now on the master branch.  You can tell because the
hello.rb file doesn't use the @Greeter@ class.

h2. Switch Back to the Greet Branch.

Execute:
git checkout greet
=checkout2
cat lib/hello.rb
=cat2

Output:
=checkout2
=cat2
EOF

p. The contents of the @lib/hello.rb@ confirms we are back on the
*greet* branch.

----------------------------------------------------------------------
h1. Changes in Master

h3. Goals

* Learning how to deal with multiple branches with different (and possibly conflicting) changes.

p. While you were changing the greet branch, someone else decided to
update the master branch.  They added a README.

h2. Update the README file with changes.

File: README
This is the Hello World example from the git tutorial.
EOF

h2. Commit the README changes to master.

Execute:
git checkout master
git add README
git commit -m "Added README"

----------------------------------------------------------------------
h1. Viewing Diverging Branches

h3. Goals

* Learn how to view diverging branches in a repository.

h2. View the Current Branches

p. We now have two diverging branches in the repository.  Use the
following log command to view the branches and how they diverge.

Execute:
git hist --all
=log

Output:
=log
EOF

p. Here is our first chance to see the @--graph@ option on @git hist@ in
action. Adding the @--graph@ option to @git log@ causes it to draw the
commit tree using simple ASCII characters.  We can see both branches
(greet and master), and that the master branch is the current HEAD.
The common ancestor to both branches is the "Added a Rakefile" branch.

p. The @--all@ flag makes sure that we see all the branches.  The
default is to show only the current branch.

----------------------------------------------------------------------
h1. Merging

h3. Goals

* Learn how to merge two diverging branches to bring the changes back into a single branch.

h2. Merge the branches

p. Merging brings the changes in two branches together.  Let's go back
to the greet branch and merge master onto greet.

Execute:
git checkout greet
=checkout
git merge master
=merge
git hist --all
=hist

Output:
=checkout
=merge
=hist
EOF

p. By merging master into your greet branch periodically, you can pick
up any changes to master and keep your changes in greet compatible
with changes in the mainline.

p. However, it does produce ugly commit graphs. Latter we will look at
the option of rebasing rather than merging.

h2. Up Next

p. But first, what if the changes in master conflict with the changes
in greet?

----------------------------------------------------------------------
h1. Creating a Conflict

h3. Goals

* Create a conflicting change in the master branch.

h2. Switch back to master and create a conflict

p. Switch back to the master branch and make this change:

Execute:
git checkout master

File: lib/hello.rb
puts "What's your name"
my_name = gets.strip

puts "Hello, #{my_name}!"
EOF

Execute:
git add lib/hello.rb
git commit -m "Made interactive"

h2. View the Branches

Execute:
git hist --all
=log

Output:
=log
EOF

p. Master at commit "Added README" has been merged to the greet
branch, but there is now an additional commit on master that has not
been merged back to greet.

h2. Up Next

p. The latest change in master conflicts with some existing changes in
greet.  Next we will resolve those changes.

----------------------------------------------------------------------
h1. Resolving Conflicts

h3. Goals

* Learn how to handle conflicts during a merge

h2. Merge master to greet

p. Now go back to the greet branch and try to merge the new master.

Execute:
git checkout greet
!git merge master

Output:
$ git checkout greet
Switched to branch 'greet'
$ git merge master
Auto-merging lib/hello.rb
CONFLICT (content): Merge conflict in lib/hello.rb
Automatic merge failed; fix conflicts and then commit the result.
EOF

If you open lib/hello.rb, you will see:

file: lib/hello.rb
<<<<<<< HEAD
require 'greeter'

# Default is World
name = ARGV.first || "World"

greeter = Greeter.new(name)
puts greeter.greet
=======
# Default is World

puts "What's your name"
my_name = gets.strip

puts "Hello, #{my_name}!"
>>>>>>> master
EOF

p. The first section is the version on the head of the current branch
(greet).  The second section is the version on the master branch.

h2. Fix the Conflict

p. You need to manually resolve the conflict.  Modify @lib/hello.rb@
to be the following.

File: lib/hello.rb
require 'greeter'

puts "What's your name"
my_name = gets.strip

greeter = Greeter.new(my_name)
puts greeter.greet
EOF

h2. Commit the Conflict Resolution

Execute:
git add lib/hello.rb
=add
git commit -m "Merged master fixed conflict."
=commit

Output:
=add
=commit
EOF

h2. Advanced Merging

p. git doesn't provide any graphical merge tools, but it will gladly
work with any third party merge tool you wish to use.  See
"http://onestepback.org/index.cgi/Tech/Git/UsingP4MergeWithGit.red":http://onestepback.org/index.cgi/Tech/Git/UsingP4MergeWithGit.red
for a description of using the Perforce merge tool with git.

----------------------------------------------------------------------
h1. Rebasing VS Merging

h3. Goals

* Learn the differences between rebasing and merging.

h3. Discussion

p. Let's explore the differences between merging and rebasing.  In
order to do so, we need to rewind the repository back in time before
the first merge, and then redo the same steps, but using rebasing
rather than merging.

p. We will make use the of the @reset@ command to wind the branches
back in time.

----------------------------------------------------------------------
h1. Resetting the Greet Branch

h3. Goals

* Reset the greet branch to the point before the first merge.

h2. Reset the greet branch

p. Let's go back in time on the greet branch to the point _before_ we
merged master onto it.  We can *reset* a branch to any commit we want.
Essentially this is modifying the branch pointer to point to anywhere
in the commit tree.

p. In this case we want to back greet up to the point prior to the
merge with master.  We need to find the last commit before the merge.

Execute:
git checkout greet
=checkout
git hist
=log

Output:
=checkout
=log
EOF

p. That's a bit hard to read, but looking at the data we see that the
"Updated Rakefile" commit was the last commit on the greet branch
before merging.  Let's reset the greet branch to that commit.

Set: hash=hash_for("Updated Rakefile")
Execute:
git reset --hard <hash>
=reset

Output:
=reset
EOF

h2. Check the branch.

p. Look at the log for the greet branch.  We no longer have the merge
commits in its history.

Execute:
git hist --all
=log2

Output:
=log2
EOF

----------------------------------------------------------------------
h1. Resetting the Master Branch

h3. Goals

* Reset the master branch to the point before the conflicting commit.

h2. Reset the master branch

p. When we added the interactive mode to the master branch, we made a
change that conflicted with changes in the greet branch. Let's rewind
the master branch to a point before the conflicting change.  This
allows us to demonstrate the rebase command without worrying about
conflicts.

Execute:
git checkout master
git hist
=log

Output:
=log
EOF

p. The 'Added README' commit is the one directly before the
conflicting interactive mode.  We will reset the master branch to
'Added README' branch.

Set: hash=hash_for("Added README")
Execute:
git reset --hard <hash>
git hist --all
=log2

p. Review the log.  It should look like the repository has been wound
back in time to the point before we merged anything.

Output:
=log2
EOF

----------------------------------------------------------------------
h1. Rebasing

h3. Goals

* Use the rebase command rather than the merge command.

p. Ok, we are back in time before the first merge and we want to get
the changes in master into our greet branch.

p. This time we will use the rebase command instead of the merge
command to bring in the changes from the master branch.

Execute:
git checkout greet
git rebase master
git hist
=log

Output:
$ go greet
Switched to branch 'greet'
$
$ git rebase master
First, rewinding head to replay your work on top of it...
Applying: added Greeter class
Applying: hello uses Greeter
Applying: updated Rakefile
$
=log
EOF

h2. Merge VS Rebase

p. The final result of the rebase is very similar to the merge.  The
greet branch now contains all of its changes, as well as all the
changes from the master branch.  However, the commit tree is quite
different.  The commit tree for the greet branch has been rewritten so
that the master branch is a part of the commit history.  This leaves
the chain of commits linear and much easier to read.

h2. When to Rebase, When to Merge?

p. Don't use rebase ...

# If the branch is public and shared with others.  Rewriting publicly shared branches will tend to screw up other members of the team.
# When the _exact_ history of the commit branch is important (since rebase rewrites the commit history).

p. Given the above guidelines, I tend to use rebase for short-lived,
local branches and merge for branches in the public repository.

----------------------------------------------------------------------
h1. Merging Back to Master

h3. Goals

* We've kept our greet branch up to date with master (via rebase), now let's merge the greet changes back into the master branch.

h2. Merge greet into master

Execute:
git checkout master
git merge greet
=merge

Output:
$ git checkout master
Switched to branch 'master'
$
=merge
EOF

p. Because the head of master is a direct ancestor of the head of the
greet branch, git is able to do a fast-forward merge.  When
fast-forwarding, the branch pointer is simply moved forward to point
to the same commit as the greeter branch.

p. There will never be conflicts in a fast-forward merge.

h2. Review the logs

Execute:
git hist
=log

Output:
=log
EOF

p. The greet and master branches are now identical.

----------------------------------------------------------------------
h1. Mutliple Repositories

p. Up to this point we have been working with a single git repository.
However, git excells at working with multiple repositories.  These
extra repositories may be stored locally, or may be accessed across a
network connection.

p. In the next section will create a new repository called
"cloned_hello".  We will show how to move changes from one repository
to another, and how to handle conflicts when they arise from between
two repositories.

 !git_clone.png!


p. For now, we will be working with local repositories
(i.e. repositories stored on your local hard disk), however most of
the things learned in this section will apply to multiple repositories
whether they are stored locally or remotely over a network.

p. *NOTE:* We are going be making changes to both copies of our
repositories.  Make sure you pay attention to which repository you are
in at each step of the following labs.

----------------------------------------------------------------------
h1. Cloning Repositories

h3. Goals

* Learn how to make copies of repositories.

h2. Go to the work directory

p. Go to the working directory and make a clone of your hello
repository.

Execute:
cd ..
=cd
pwd
=pwd
ls
=ls

p{color:red}. *NOTE: Now in the work directory.*

Output:
=cd
=pwd
=ls
EOF

p. At this point you should be in your "work" directory.  There should
be a single repository here named "hello".

h2. Create a clone of the hello repository

p. Let's make a clone of the repository.

Execute:
git clone hello cloned_hello
=clone
ls
=ls2
+cd cloned_hello
+git config user.name "Jim Weirich"
+git config user.email "jim (at) edgecase.com"
+cd ..

Output:
=clone
=ls2
EOF

p. There should now be two repositories in your work directory: the
original "hello" repository and the newly cloned "cloned_hello"
repository.

----------------------------------------------------------------------
h1. Review the Cloned Repository

h3. Goals

* Learn about branches on remote repositories.

h2. Look at the cloned repository

p. Let's take a look at the cloned repository.

Execute:
cd cloned_hello
=cd
ls
=ls

Output:
=cd
=ls
EOF

p. You should see a list of all the files in the top level of the
original repository (@README@, @Rakefile@ and @lib@).


h2. Review the Repository History

Execute:
git hist --all
=log

Output:
=log
EOF

p. You should now see a list of the all the commits in the new
repository, and it should (more or less) match the history of commits
in the original repository.  The only difference should be in the
names of the branches.

h2. Remote branches

p. You should see a *master* branch (along with *HEAD*) in the history
list.  But you will also have number of strangely named branches
(*origin/master*, *origin/greet* and *origin/HEAD*).  We'll talk about
them in a bit.

----------------------------------------------------------------------
h1. What is Origin?

h3. Goals

* Learn about naming remote repositories.

Execute:
git remote
=remote

Output:
=remote
EOF

p. We see that the cloned repository knows about a remote repository
named origin.  Let's see if we can get more information about origin:

Execute:
git remote show origin
=show

Output:
=show
EOF

p. Now we see that the remote repository "origin" is simply the original
*hello* repository.  Remote repositories typically live on a separate
machine, possibly a centralized server.  As we can see here, however,
they can just as well point to a repository on the same machine.  
There is nothing particularly special about the name "origin", 
however the convention is to use the name "origin" for
the primary centralized repository (if there is one).

----------------------------------------------------------------------
h1. Remote Branches

h3. Goals

* Learn about local VS remote branches

p. Let's look at the branches available in our cloned repository.

Execute:
git branch
=branch

Output:
=branch
EOF

p. That's it, only the master branch is listed.  Where is the greet
branch?  The *git* *branch* command only lists the local branches by
default.

h2. List Remote Branches

p. Try this to see all the branches:

Execute:
git branch -a
=branch_a

Output:
=branch_a
EOF

p. Git has all the commits from the original repository, but branches
in the remote repository are not treated as local branches here.  If
we want our own *greet* branch, we need to create it ourselves. We
will see how to do that in a minute.

----------------------------------------------------------------------
h1. Change the Original Repository

h3. Goals

* Make some changes to the original repository so we can try to pull the changes

h2. Make a change in the original *hello* repository

Execute:
cd ../hello
+pwd
# (You should be in the original hello repository now)

p{color:red}. *NOTE: Now in the _hello_ repo*

p. Make the following changes to README:

File: README
This is the Hello World example from the git tutorial.
(changed in original)
EOF

p. Now add and commit this change

Execute:
git add README
git commit -m "Changed README in original repo"

h2. Up Next

p. The original repository now has later changes that are not in the
cloned version.  Next we will pull those changes across to the cloned
repository.

----------------------------------------------------------------------
h1. Fetching Changes

h3. Goals

* Learn how to pull changes from a remote repository.

Execute:
cd ../cloned_hello
+pwd
git fetch
=fetch
git hist --all
=hist

p{color:red}. *NOTE: Now in the _cloned_hello_ repo*

Output:
=fetch
=hist
EOF

p. At this point the repository has all the commits from the original
repository, but they are not integrated into the the cloned
repository's local branches.

p. Find the "Changed README in original repo" commit in the history
above.  Notice that the commit includes "origin/master" and
"origin/HEAD".

p. Now look at the "Updated Rakefile" commit.  You will see that it
the local master branch points to this commit, not to the new commit
that we just fetched.

p. The upshot of this is that the "git fetch" command will fetch new
commits from the remote repository, but it will not merge these
commits into the local branches.

h2. Check the README

We can demonstrate that the cloned README is unchanged.

Execute:
cat README

Output:
$ cat README
This is the Hello World example from the git tutorial.
EOF

p. See, no changes.

----------------------------------------------------------------------
h1. Merging Pulled Changes

h3. Goals

* Learn to get the pulled changes into the current branch and working directory.

h2. Merge the fetched changes into local master

Execute:
git merge origin/master
=merge

Output:
=merge
EOF

h2. Check the README again

p. We should see the changes now.

Execute:
cat README

Output:
$ cat README
This is the Hello World example from the git tutorial.
(changed in original)
EOF

p. There are the changes.  Even though "git fetch" does not merge the
changes, we can still manually merge the changes from the remote
repository.

h2. Up Next

p. Next let's take a look at combining the fetch & merge process into
a single command.

----------------------------------------------------------------------
h1. Pulling Changes

h3. Goals

* Learn that @git pull@ is equivalent to a @git fetch@ followed by a @git merge@.

h3. Discussion

p. We're not going to go through the process of creating another
change and pulling it again, but we do want you to know that doing:

pre(instructions). git pull

is indeed equivalent to the two steps:

pre(instructions). git fetch
git merge origin/master

----------------------------------------------------------------------
h1. Adding a Tracking Branch

h3. Goals

* Learn how to add a local branch that tracks a remote branch.

p. The branches starting with remotes/origin are branches from the
original repo.  Notice that you don't have a branch called greet
anymore, but it knows that the original repo had a greet branch.

h2. Add a local branch that tracks a remote branch.

Execute:
git branch --track greet origin/greet
=branch_track
git branch -a
=branch_a
git hist --max-count=2
=log

Output:
=branch_track
=branch_a
=log
EOF

p. We can now see the greet branch in the branch list and in the log.

----------------------------------------------------------------------
h1. Bare Repositories

h3. Goals

* Learn how to create bare repositories.

p. Bare repositories (without working directories) are usually used for
sharing).

h2. Create a bare repository.

Execute:
cd ..
+pwd
git clone --bare hello hello.git
=clone
ls hello.git
=ls

p{color:red}. *NOTE: Now in the work directory*

Output:
=clone
=ls
EOF

p. The convention is that repositories ending in '.git' are bare
repositories.  We can see that there is no working directory in the
hello.git repo.  Essentially it is nothing but the .git directory of a
non-bare repo.

----------------------------------------------------------------------
h1. Adding a Remote Repository

h3. Goals

* Add the bare repository as a remote to our original repository.

p. Let's add the hello.git repo to our original repo.

Execute:
cd hello
+pwd
git remote add shared ../hello.git

p{color:red}. *NOTE: Now in the +hello+ repository.*

----------------------------------------------------------------------
h1. Pushing a Change

h3. Goals

* Learn how out to push a change to a remote repository.

p. Since bare repositories are usually shared on some sort of network
server, it is usually difficult to cd into the repo and pull changes.
So we need to push our changes into other repositories.

p. Let's start by creating a change to be pushed.  Edit the README and
commit it

File: README
This is the Hello World example from the git tutorial.
(Changed in the original and pushed to shared)
EOF

Execute:
git checkout master
git add README
git commit -m "Added shared comment to readme"

p. Now push the change to the shared repo.

Execute:
git push shared master
=push

p. _shared_ is the name of the repository receiving the changes we are
pushing. (Remember, we added it as a remote in the previous lab.)

Output:
=push
EOF

p(note). *NOTE:* We had to explicitly name the branch master that was
receiving the push.  It is possible to set it up automatically, but I
_never_ remember the commands to do that.  Check out the "Git Remote
Branch" gem for easy management of remote branches.

----------------------------------------------------------------------
h1. Pulling Shared Changes

h3. Goals

* Learn how to pull changes from a shared repository.

p. Quick hop over to the clone repository and let's pull down the
changes just pushed to the shared repo.

Execute:
cd ../cloned_hello
+pwd

p{color:red}. *NOTE: Now in the _cloned_hello_ repo.*

p. Continue with...

Execute:
git remote add shared ../hello.git
git branch --track shared master
git pull shared master
cat README

----------------------------------------------------------------------
h1. Hosting your Git Repositories

h3. Goals

* Learn how to setup git server for sharing repositories.

p. There are many ways to share git repositories over the network.
Here is a quick and dirty way.

h2. Start up the git server

execute:
# (From the work directory)
git daemon --verbose --export-all --base-path=.

p. Now, in a separate terminal window, go to your work directory

execute:
# (From the work directory)
git clone git://localhost/hello.git network_hello
cd network_hello
ls

p. You should see a copy of hello project.

h2. Pushing to the Git Daemon

p. If you want to push to the git daemon repository, add
@--enable=receive-pack@ to the git daemon command.  Be careful because
there is no authentication on this server, anyone could push to your
repository.

----------------------------------------------------------------------
h1. Sharing Repos

h3. Goals

* Learn to share repos across WIFI.

p. See if your neighbor is running the git daemon.  Exchange IP
addresses and see if you can pull from each other's repositories.

p(note). *NOTE:* The gitjour gem is really useful in sharing
ad-hoc repositories.

----------------------------------------------------------------------
h1. Advanced / Future Topics

p. Here are some topics you might want to research on your own:

* Reverting Committed Changes
* Cross OS Line Endings
* Remote Servers
* Protocols
* SSH Setup
* Remote Branch Management
* Finding Buggy Commits (git bisect)
* Workflows
* Non-command line tools (gitx, gitk, magit)
* Working with GitHub

----------------------------------------------------------------------
h1. Thank You

p. Thank you for trying out the Git Immersion Labs.  Feel free to send
comments to jim.weirich@gmail.com.

